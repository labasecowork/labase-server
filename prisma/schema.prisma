// puedes aprender más sobre él en la documentación: https://pris.ly/d/prisma-schema
// ¿Buscas formas de acelerar tus consultas o escalar fácilmente con tus funciones serverless o edge?
// Prueba Prisma Accelerate: https://pris.ly/cli/accelerate-init
// npx prisma generate
// npx prisma migrate reset
// npx prisma migrate dev --init
// npx prisma studio

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum user_type {
  admin // Usuario administrador (superadmin o manager)
  client // Usuario cliente que reserva espacios
  employee // Usuario empleado que trabaja en la empresa
}

enum admin_role {
  superadmin // Rol con permisos totales (crea otros superadmins y managers)
  manager // Rol con permisos limitados (solo puede crear managers)
}

enum user_status {
  active // Usuario activo
  suspended // Usuario suspendido
  pending // Usuario pendiente de verificación o activación
}

enum notification_type {
  info // Notificación informativa
  success // Operación exitosa
  error // Error en la operación
  alert // Alerta importante
}

enum space_type {
  unit // Unidad individual (privada)
  shared_site // Sitio individual en espacio compartido
  full_room // Reserva de todo el espacio (sala completa)
}

enum access_type {
  public // Visible y reservable por cualquier cliente
  private // Reservable solo por admin o bajo condiciones especiales
}

enum duration_unit {
  hour
  day
  week
  month
}

enum price_mode {
  individual // Precio por sitio / unidad
  group // Precio por reserva de sala completa
}

enum reservation_status {
  pending // Estado inicial al crear una reserva. Aún no se ha pagado.
  confirmed // Estado asignado cuando el pago fue APROBADO por el proveedor (Niubiz).
  cancelled // Estado cuando un admin o cliente cancela manualmente la reserva, o vence el tiempo de espera sin pagar.
  in_progress // Estado al momento de escanear el código QR de una reserva CONFIRMADA **y** dentro del horario.
}

enum payment_status {
  pending // Estado inicial al crear el flujo de pago (aún sin generar sessionToken).
  ready // Estado cuando se ha generado correctamente el `sessionToken` y script de pago (checkout.js).
  approved // Estado final cuando el proveedor aprueba el pago del cliente.
  canceled // Pago cancelado manualmente por el usuario (desde frontend o backend).
  failed // El proveedor rechazó el pago (tarjeta inválida, error interno, etc.).
}

enum article_status {
  pending
  accepted
  rejected
}

enum community_user_type {
  moderator // Moderador de la comunidad
  member // Miembro de la comunidad
}

enum reaction_type {
  like // Me gusta
  dislike // No me gusta
}

enum reaction_target {
  publication // Reacción a una publicación
  comment // Reacción a un comentario
  reply // Reacción a una respuesta
}

enum attendance_type {
  entry // Entrada
  exit // Salida
}

enum unit_of_measure {
  unit // unidad
  kilogram // kilogramo
  meter // metro
  piece // pieza
}

enum company_type {
  internal // La Base
  tenant // Empresa inquilina
}

enum gender {
  male // Hombre
  female // Mujer
  unspecified // Sin especificar
}

model users {
  id                 String      @id @default(uuid()) // Identificador único del usuario
  first_name         String // Nombre del usuario
  last_name          String // Apellido del usuario
  email              String      @unique // Correo electrónico único
  password           String // Contraseña hasheada
  user_type          user_type? // Tipo de usuario (admin o client)
  profile_image      String? // Imagen de perfil del usuario
  phone              String? // Número telefónico del usuario
  birth_date         DateTime?   @db.Date // Fecha de nacimiento
  gender             gender      @default(unspecified) // Género del usuario
  status             user_status // Estado actual del usuario
  creation_timestamp DateTime    @default(now()) // Fecha de creación del registro

  admin_details        admin_details? // Relación uno a uno si es admin
  employee_details     employee_details?
  user_details         user_details? // Relación uno a uno para detalles generales
  reservations         reservation[]         @relation("user_reservations") // Reservas realizadas por el usuario
  payment_transactions payment_transaction[] @relation("user_payments")
  articles             articles[]            @relation("user_articles")
  client_details       client_details?
  visitors             visitors[]

  @@map("users") // (opcional; ya está en snake_case)
}

model admin_details {
  admin_id String     @id // ID del admin (igual al ID en users.id)
  role     admin_role // Rol del administrador
  notes    String? // Notas administrativas adicionales

  user users @relation(fields: [admin_id], references: [id], onDelete: Cascade) // Relación con users

  @@map("admin_details")
}

model user_details {
  user_id String      @id // ID del usuario
  status  user_status // (volátil) Duplicado de users.status; revisar si realmente se requiere aquí

  user users @relation(fields: [user_id], references: [id], onDelete: Cascade) // Relación con users

  @@map("user_details")
}

model work_areas {
  id          String   @id @default(uuid())
  name        String
  description String?
  capacity    Int
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  employees employee_details[]

  @@map("work_areas")
}

model companies {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  employees employee_details[]

  clients  client_details[]
  visitors visitors[]

  @@map("companies")
}

model employee_details {
  employee_id String @id
  user        users  @relation(fields: [employee_id], references: [id])

  work_area_id String?
  company_id   String?

  work_area work_areas? @relation(fields: [work_area_id], references: [id], onDelete: SetNull)
  company   companies?  @relation(fields: [company_id], references: [id], onDelete: SetNull)

  attendances attendance[]
  visitors    visitors[]

  @@index([work_area_id])
  @@index([company_id])
  @@map("employee_details")
}

model attendance {
  id          String          @id @default(uuid())
  employee_id String
  type        attendance_type
  date        DateTime        @db.Date
  check_time  DateTime        @db.Time

  employee employee_details @relation(fields: [employee_id], references: [employee_id], onDelete: Cascade)

  @@map("attendances")
}

model space {
  id              String      @id @default(uuid()) // ID del espacio
  name            String // Nombre del espacio (ej: Hangar, Unidad)
  description     String? // Descripción opcional
  type            space_type // Tipo de espacio (privado, compartido, etc.)
  access          access_type // Acceso público o privado
  capacity_min    Int // Mínimo de personas por reserva
  capacity_max    Int // Máximo de personas permitidas en el espacio
  allow_by_unit   Boolean // ¿Se permiten reservas “por unidad” (sitio individual).
  allow_full_room Boolean // Permite reservar toda la sala de una sola vez.
  disabled        Boolean     @default(false) // ¿Deshabilitado?
  created_at      DateTime    @default(now()) // Fecha de creación del espacio

  space_images   space_image[]
  space_benefits space_benefit[]
  prices         price[] // Relación: precios por duración
  reservations   reservation[] // Relación: reservas registradas para este espacio
  visitors       visitors[] // Relación: visitantes que ingresaron a este espacio

  @@map("spaces")
}

model space_image {
  id       String  @id @default(uuid())
  space_id String
  url      String // URL en S3
  alt      String? // opcional
  position Int     @default(0) // orden

  space space @relation(fields: [space_id], references: [id], onDelete: Cascade)

  @@index([space_id, position])
  @@map("space_images")
}

model benefit {
  id          String  @id @default(uuid())
  name        String  @unique
  description String?

  spaces space_benefit[]

  @@map("benefits")
}

model space_benefit {
  space_id   String
  benefit_id String

  space   space   @relation(fields: [space_id], references: [id], onDelete: Cascade)
  benefit benefit @relation(fields: [benefit_id], references: [id], onDelete: Cascade)

  @@id([space_id, benefit_id])
  @@map("space_benefits")
}

model price {
  id       String        @id @default(uuid()) // ID del registro de precio
  space_id String // FK al espacio asociado
  duration duration_unit // Tipo de duración (hora, día, semana)
  mode     price_mode
  amount   Float // Monto en moneda local

  space space @relation(fields: [space_id], references: [id], onDelete: Cascade)

  @@unique([space_id, duration, mode])
  @@map("prices")
}

model reservation {
  id              String             @id @default(uuid()) // ID de la reserva
  purchase_number String             @unique // Número de compra generado
  user_id         String // FK al usuario que reservó
  space_id        String // FK al espacio reservado
  start_time      DateTime // Fecha y hora de inicio de la reserva
  end_time        DateTime // Fecha y hora de fin de la reserva
  people          Int // Número total de personas
  full_room       Boolean // ¿Se reservó todo el espacio?
  code_qr         String             @unique // Código QR
  price           Decimal // Precio a cobrar
  status          reservation_status @default(pending)
  created_at      DateTime           @default(now()) // Timestamp de creación

  user  users @relation("user_reservations", fields: [user_id], references: [id], onDelete: Cascade)
  space space @relation(fields: [space_id], references: [id], onDelete: Cascade)

  slots                reservation_slot[] // Relación a los slots individuales (opcional)
  payment_transactions payment_transaction[] @relation("reservation_payments")

  @@index([space_id, start_time, end_time]) // Index para verificar conflictos
  @@index([user_id, created_at]) // Para listar reservas por usuario/fecha
  @@map("reservations")
}

model reservation_slot {
  id             String @id @default(uuid()) // ID del slot individual
  reservation_id String // FK a  la reserva principal
  slot_number    Int // Número de sitio asignado (1 a N)

  reservation reservation @relation(fields: [reservation_id], references: [id], onDelete: Cascade)

  @@unique([reservation_id, slot_number]) // Un sitio por reserva
  @@map("reservation_slots")
}

model payment_transaction {
  id                 String         @id @default(uuid())
  transaction_id     String         @db.VarChar(50)
  purchase_number    String         @unique @db.VarChar(50)
  amount             Float
  authorization_code String?        @db.VarChar(20)
  status             payment_status
  action_description String?        @db.VarChar(100)
  card_masked        String?        @db.VarChar(25)
  transaction_date   String         @db.VarChar(20)
  error_code         Int?
  error_message      String?        @db.VarChar(100)
  created_at         DateTime       @default(now())

  reservation_id String?
  reservation    reservation? @relation(fields: [reservation_id], references: [id], onDelete: Cascade, name: "reservation_payments")

  user_id String?
  user    users?  @relation("user_payments", fields: [user_id], references: [id])

  @@index([status, created_at]) // Buscar pagos por estado/fecha
  @@map("payment_transactions")
}

model article_categories {
  id          String  @id @default(uuid())
  name        String  @unique
  description String?

  articles articles[]

  @@map("article_categories")
}

model articles {
  id           String  @id @default(uuid())
  author_id    String
  category_id  String
  title        String
  content      String
  banner       String?
  resume       String
  reading_time Int

  publication_timestamp DateTime?
  status                article_status @default(pending)

  author           users              @relation("user_articles", fields: [author_id], references: [id], onDelete: Cascade)
  article_category article_categories @relation(fields: [category_id], references: [id], onDelete: Cascade)

  @@index([status])
  @@map("articles")
}

model newsletter_subscriber {
  id         String   @id @default(uuid())
  name       String
  email      String   @unique
  created_at DateTime @default(now())

  @@map("newsletter_subscribers")
}

model products {
  id              String          @id @default(uuid())
  name            String
  photo_url       String
  brand_id        String
  unit_of_measure unit_of_measure
  description     String?
  observations    String?
  quantity        Int

  brand product_brand @relation(fields: [brand_id], references: [id], onDelete: Restrict)

  @@map("products")
}

model product_brand {
  id         String   @id @default(uuid())
  name       String   @unique
  created_at DateTime @default(now())

  products products[] // inversa correcta

  @@map("product_brand") // nombre de tabla real (si quieres plural, usa "product_brands")
}

model visitors {
  id         String    @id @default(uuid()) // Identificador único
  dni        String?   @unique // DNI (si es persona natural)
  ruc        String?   @unique // RUC (si es empresa/independiente)
  first_name String // Nombre
  last_name  String // Apellido
  phone      String? // Teléfono
  email      String? // Correo
  user_id    String // A quién visita (FK a client_details)
  company_id String? // Compañía del cliente (redundante pero útil p/queries)
  space_id   String // Espacio visitado (FK a space)
  entry_time DateTime // Hora de entrada
  exit_time  DateTime? // Hora de salida (opcional)
  created_at DateTime  @default(now())

  user                        users             @relation(fields: [user_id], references: [id], onDelete: Cascade)
  company                     companies?        @relation(fields: [company_id], references: [id], onDelete: SetNull)
  space                       space             @relation(fields: [space_id], references: [id], onDelete: Cascade)
  employee_details            employee_details? @relation(fields: [employee_detailsEmployee_id], references: [employee_id])
  employee_detailsEmployee_id String?

  @@index([user_id, created_at])
  @@index([space_id, created_at])
  @@index([company_id])
  @@map("visitors")
}

model client_details {
  client_id String @id
  user      users  @relation(fields: [client_id], references: [id], onDelete: Cascade)

  company_id String?
  company    companies? @relation(fields: [company_id], references: [id], onDelete: SetNull)

  @@index([company_id])
  @@map("client_details")
}
