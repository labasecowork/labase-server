// puedes aprender más sobre él en la documentación: https://pris.ly/d/prisma-schema
// ¿Buscas formas de acelerar tus consultas o escalar fácilmente con tus funciones serverless o edge?
// Prueba Prisma Accelerate: https://pris.ly/cli/accelerate-init
// npx prisma generate
// npx prisma migrate reset
// npx prisma migrate dev --init
// npx prisma studio

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum user_type {
  admin // Usuario administrador (superadmin o manager)
  client // Usuario cliente que reserva espacios
  employee // Usuario empleado que trabaja en la empresa
}

enum admin_role {
  superadmin // Rol con permisos totales (crea otros superadmins y managers)
  manager // Rol con permisos limitados (solo puede crear managers)
}

enum user_status {
  active // Usuario activo
  suspended // Usuario suspendido
  pending // Usuario pendiente de verificación o activación
}

enum notification_type {
  info // Notificación informativa
  success // Operación exitosa
  error // Error en la operación
  alert // Alerta importante
}

enum space_type {
  unit // Unidad individual (privada)
  shared_site // Sitio individual en espacio compartido
  full_room // Reserva de todo el espacio (sala completa)
}

enum access_type {
  public // Visible y reservable por cualquier cliente
  private // Reservable solo por admin o bajo condiciones especiales
}

enum duration_unit {
  hour
  day
  week
  month
}

enum price_mode {
  individual // Precio por sitio / unidad
  group // Precio por reserva de sala completa
}

enum reservation_status {
  pending // Estado inicial al crear una reserva. Aún no se ha pagado.
  confirmed // Estado asignado cuando el pago fue APROBADO por el proveedor (Niubiz).
  cancelled // Estado cuando un admin o cliente cancela manualmente la reserva, o vence el tiempo de espera sin pagar.
  in_progress // Estado al momento de escanear el código QR de una reserva CONFIRMADA **y** dentro del horario.
}

enum payment_status {
  pending // Estado inicial al crear el flujo de pago (aún sin generar sessionToken).
  ready // Estado cuando se ha generado correctamente el `sessionToken` y script de pago (checkout.js).
  approved // Estado final cuando el proveedor aprueba el pago del cliente.
  canceled // Pago cancelado manualmente por el usuario (desde frontend o backend).
  failed // El proveedor rechazó el pago (tarjeta inválida, error interno, etc.).
}

enum article_status {
  pending
  accepted
  rejected
}

enum community_user_type {
  moderator // Moderador de la comunidad
  member // Miembro de la comunidad
}

enum reaction_type {
  like // Me gusta
  dislike // No me gusta
}

enum reaction_target {
  publication // Reacción a una publicación
  comment // Reacción a un comentario
  reply // Reacción a una respuesta
}


enum unit_of_measure {
  unit // unidad
  kilogram // kilogramo
  meter // metro
  piece // pieza
}

enum company_type {
  internal // La Base
  tenant // Empresa inquilina
}

enum gender {
  male // Hombre
  female // Mujer
  unspecified // Sin especificar
}

// tipo de colaborador
enum employee_kind {
  intern        // practicante
  contractor    // contratado
  payroll       // planilla
}

//tipo de punto (A–D)
enum attendance_type {
  entry        // A
  lunch_out    // B
  lunch_in     // C
  exit         // D
}

//modalidad de asistencia por día
enum work_mode {
  onsite
  remote
}

model users {
  id                 String   @id @default(uuid())
  first_name         String
  last_name          String
  email              String   @unique
  password           String
  user_type          user_type?
  profile_image      String?
  phone              String?
  birth_date         DateTime? @db.Date
  gender             gender    @default(unspecified)
  status             user_status
  creation_timestamp DateTime  @default(now())

  admin_details        admin_details?
  employee_details     employee_details?
  user_details         user_details?
  reservations         reservation[]         @relation("user_reservations")
  payment_transactions payment_transaction[] @relation("user_payments")
  articles             articles[]            @relation("user_articles")

  hosted_visitors visitors[] @relation("visitor_host")

  @@map("users")
}

model admin_details {
  admin_id String     @id // ID del admin (igual al ID en users.id)
  role     admin_role // Rol del administrador
  notes    String? // Notas administrativas adicionales

  user users @relation(fields: [admin_id], references: [id], onDelete: Cascade) // Relación con users

  @@map("admin_details")
}

model user_details {
  user_id String      @id // ID del usuario
  status  user_status // (volátil) Duplicado de users.status; revisar si realmente se requiere aquí

  user users @relation(fields: [user_id], references: [id], onDelete: Cascade) // Relación con users

  @@map("user_details")
}

model work_areas {
  id          String   @id @default(uuid())
  name        String
  description String?
  capacity    Int
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  employees employee_details[]

  @@map("work_areas")
}

model companies {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  employees employee_details[]

  visitors visitors[]

  @@map("companies")
}

model employee_details {
  employee_id String @id
  user        users  @relation(fields: [employee_id], references: [id])

  work_area_id String?
  company_id   String?

  kind        employee_kind?         // intern/contractor/payroll
  is_active   Boolean                @default(true)

  work_area work_areas? @relation(fields: [work_area_id], references: [id], onDelete: SetNull)
  company   companies?  @relation(fields: [company_id], references: [id], onDelete: SetNull)

  attendance_points attendance_points[]
  schedules         employee_schedules[]
  policy            employee_attendance_policies?

  visitors visitors[]

  @@index([work_area_id])
  @@index([company_id])
  @@map("employee_details")
}

/// Política por empleado
model employee_attendance_policies {
  id                    String  @id @default(uuid())
  employee_id           String  @unique
  grace_entry_minutes   Int     @default(5)    // tolerancia de ingreso
  early_before_minutes  Int     @default(15)   // permitir marcar hasta 15' antes
  exit_late_minutes     Int     @default(10)   // tolerancia para marcar salida
  require_four_points   Boolean @default(false) // 2 puntos (false) o 4 puntos (true)
  min_daily_hours       Int     @default(8)    // interns pueden tener 4 (editable)
  created_at            DateTime @default(now())
  updated_at            DateTime @updatedAt

  employee employee_details @relation(fields: [employee_id], references: [employee_id], onDelete: Cascade)

  @@map("employee_attendance_policies")
}

/// Horario por día con modalidad y ventanas de almuerzo
model employee_schedules {
  id               String    @id @default(uuid())
  employee_id      String
  weekday          Int       // 1=Lunes ... 7=Domingo
  mode             work_mode // onsite/remote por día
  expected_points  Int       @default(2) // validar en app: 2 o 4
  entry_time       DateTime? @db.Time   // A
  lunch_out_time   DateTime? @db.Time   // B
  lunch_in_time    DateTime? @db.Time   // C
  exit_time        DateTime? @db.Time   // D
  min_lunch_minutes Int?
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  employee employee_details @relation(fields: [employee_id], references: [employee_id], onDelete: Cascade)

  @@unique([employee_id, weekday])
  @@index([employee_id, weekday])
  @@map("employee_schedules")
}

/// marcaciones por punto para un día
model attendance_points {
  id           String          @id @default(uuid())
  employee_id  String
  date         DateTime        @db.Date
  mark_type    attendance_type
  mark_time    DateTime        @db.Time

  // Flags de validación
  in_schedule  Boolean         @default(true)
  is_late      Boolean         @default(false)
  is_early     Boolean         @default(false)
  is_remote    Boolean         @default(false)

  // Auditoría / ediciones
  is_manual            Boolean   @default(false)
  edited_by_admin_id   String?   
  edited_at            DateTime?
  edit_reason          String?

  // Observaciones del propio punto
  note String @default("")


  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  // Relaciones
  employee  employee_details @relation(fields: [employee_id], references: [employee_id], onDelete: Cascade)

  @@unique([employee_id, date, mark_type])
  @@index([employee_id, date])
  @@index([date])
  @@map("attendance_points")
}

model space {
  id              String      @id @default(uuid()) // ID del espacio
  name            String // Nombre del espacio (ej: Hangar, Unidad)
  description     String? // Descripción opcional
  type            space_type // Tipo de espacio (privado, compartido, etc.)
  access          access_type // Acceso público o privado
  capacity_min    Int // Mínimo de personas por reserva
  capacity_max    Int // Máximo de personas permitidas en el espacio
  allow_by_unit   Boolean // ¿Se permiten reservas “por unidad” (sitio individual).
  allow_full_room Boolean // Permite reservar toda la sala de una sola vez.
  disabled        Boolean     @default(false) // ¿Deshabilitado?
  created_at      DateTime    @default(now()) // Fecha de creación del espacio

  space_images   space_image[]
  space_benefits space_benefit[]
  prices         price[] // Relación: precios por duración
  reservations   reservation[] // Relación: reservas registradas para este espacio
  visitors       visitors[] // Relación: visitantes que ingresaron a este espacio

  @@map("spaces")
}

model space_image {
  id       String  @id @default(uuid())
  space_id String
  url      String // URL en S3
  alt      String? // opcional
  position Int     @default(0) // orden

  space space @relation(fields: [space_id], references: [id], onDelete: Cascade)

  @@index([space_id, position])
  @@map("space_images")
}

model benefit {
  id          String  @id @default(uuid())
  name        String  @unique
  description String?

  spaces space_benefit[]

  @@map("benefits")
}

model space_benefit {
  space_id   String
  benefit_id String

  space   space   @relation(fields: [space_id], references: [id], onDelete: Cascade)
  benefit benefit @relation(fields: [benefit_id], references: [id], onDelete: Cascade)

  @@id([space_id, benefit_id])
  @@map("space_benefits")
}

model price {
  id       String        @id @default(uuid()) // ID del registro de precio
  space_id String // FK al espacio asociado
  duration duration_unit // Tipo de duración (hora, día, semana)
  mode     price_mode
  amount   Float // Monto en moneda local

  space space @relation(fields: [space_id], references: [id], onDelete: Cascade)

  @@unique([space_id, duration, mode])
  @@map("prices")
}

model reservation {
  id              String             @id @default(uuid()) // ID de la reserva
  purchase_number String             @unique // Número de compra generado
  user_id         String // FK al usuario que reservó
  space_id        String // FK al espacio reservado
  start_time      DateTime // Fecha y hora de inicio de la reserva
  end_time        DateTime // Fecha y hora de fin de la reserva
  people          Int // Número total de personas
  full_room       Boolean // ¿Se reservó todo el espacio?
  code_qr         String             @unique // Código QR
  price           Decimal // Precio a cobrar
  status          reservation_status @default(pending)
  created_at      DateTime           @default(now()) // Timestamp de creación

  user  users @relation("user_reservations", fields: [user_id], references: [id], onDelete: Cascade)
  space space @relation(fields: [space_id], references: [id], onDelete: Cascade)

  slots                reservation_slot[] // Relación a los slots individuales (opcional)
  payment_transactions payment_transaction[] @relation("reservation_payments")

  @@index([space_id, start_time, end_time]) // Index para verificar conflictos
  @@index([user_id, created_at]) // Para listar reservas por usuario/fecha
  @@map("reservations")
}

model reservation_slot {
  id             String @id @default(uuid()) // ID del slot individual
  reservation_id String // FK a  la reserva principal
  slot_number    Int // Número de sitio asignado (1 a N)

  reservation reservation @relation(fields: [reservation_id], references: [id], onDelete: Cascade)

  @@unique([reservation_id, slot_number]) // Un sitio por reserva
  @@map("reservation_slots")
}

model payment_transaction {
  id                 String         @id @default(uuid())
  transaction_id     String         @db.VarChar(50)
  purchase_number    String         @unique @db.VarChar(50)
  amount             Float
  authorization_code String?        @db.VarChar(20)
  status             payment_status
  action_description String?        @db.VarChar(100)
  card_masked        String?        @db.VarChar(25)
  transaction_date   String         @db.VarChar(20)
  error_code         Int?
  error_message      String?        @db.VarChar(100)
  created_at         DateTime       @default(now())

  reservation_id String?
  reservation    reservation? @relation(fields: [reservation_id], references: [id], onDelete: Cascade, name: "reservation_payments")

  user_id String?
  user    users?  @relation("user_payments", fields: [user_id], references: [id])

  @@index([status, created_at]) // Buscar pagos por estado/fecha
  @@map("payment_transactions")
}

model article_categories {
  id          String  @id @default(uuid())
  name        String  @unique
  description String?

  articles articles[]

  @@map("article_categories")
}

model articles {
  id           String  @id @default(uuid())
  author_id    String
  category_id  String
  title        String
  content      String
  banner       String?
  resume       String?
  reading_time Int

  publication_timestamp DateTime?
  status                article_status @default(pending)

  author           users              @relation("user_articles", fields: [author_id], references: [id], onDelete: Cascade)
  article_category article_categories @relation(fields: [category_id], references: [id], onDelete: Cascade)

  @@index([status])
  @@map("articles")
}

model newsletter_subscriber {
  id         String   @id @default(uuid())
  name       String
  email      String   @unique
  created_at DateTime @default(now())

  @@map("newsletter_subscribers")
}

model products {
  id              String          @id @default(uuid())
  name            String
  photo_url       String
  brand_id        String
  unit_of_measure unit_of_measure
  description     String?
  observations    String?
  quantity        Int

  brand product_brand @relation(fields: [brand_id], references: [id], onDelete: Restrict)

  @@map("products")
}

model product_brand {
  id         String   @id @default(uuid())
  name       String   @unique
  created_at DateTime @default(now())

  products products[] // inversa correcta

  @@map("product_brand") // nombre de tabla real (si quieres plural, usa "product_brands")
}

model visitors {
  id         String    @id @default(uuid()) // Identificador único
  dni        String?   // DNI (si es persona natural)
  ruc        String?   // RUC (si es empresa/independiente)
  first_name String // Nombre
  last_name  String // Apellido
  phone      String? // Teléfono
  email      String? // Correo
  host_user_id String // A quién visita (FK a client_details)
  company_id String? // Compañía del cliente (redundante pero útil p/queries)
  space_id   String // Espacio visitado (FK a space)WWWSW
  entry_time DateTime // Hora de entrada
  exit_time  DateTime? // Hora de salida (opcional)
  created_at DateTime  @default(now())

  host         users      @relation("visitor_host", fields: [host_user_id], references: [id], onDelete: Cascade)

  company                     companies?        @relation(fields: [company_id], references: [id], onDelete: SetNull)
  space                       space             @relation(fields: [space_id], references: [id], onDelete: Cascade)
  employee_details            employee_details? @relation(fields: [employee_detailsEmployee_id], references: [employee_id])
  employee_detailsEmployee_id String?

  @@index([host_user_id, created_at]) 
  @@index([space_id, created_at])
  @@index([company_id])
  @@map("visitors")
}
